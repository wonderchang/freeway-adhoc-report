<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Freeway Ad-Hoc</title>
    <link rel="stylesheet" href="./style.css" />
  </head>
  <body>
    <div class="page" style="height: 8000px;">

      <header class="text-center">
	<h1>高速公路車載網路之<br />封包傳遞效能成本模擬分析</h1>
	<h3>EE103A E24990019 張遠哲</h3>
	<h3>指導老師：蘇淑茵</h3>
      </header>

      <section>
	<h2>報告摘要</h2>
	<div id="freeway"></div>
	<p class="layer1">
	  &nbsp;&nbsp;&nbsp;&nbsp;
	  車載網路是以移動中的車輛及交通設施作為節點, 透過Ad-Hoc的網路架構，形成一個行動通訊網路，
	  加入網路的車輛，會成為一個無線節點，或是無線路由，並允許在特定的距離內的其他汽車彼此連結，在交通路線上形成一個大範圍的網路。
	  這樣的網路系統，可以被廣泛使用在事故路況的即時回報，並讓後方的車輛能提早了解前方事故並做應變措施。
	  而本報告為模擬在高速公路中，行駛車輛之間所形成的網路，在不同的距離、訊號收發次數、甚至是外在環境干擾的影響之下，
	  通訊封包再傳遞的效能與成本之間的比率變化。
	</p>
      </section>

      <section>
	<h2>封包的傳遞效能與接收成本</h2>
	<p class="layer1">
	  &nbsp;&nbsp;&nbsp;&nbsp;
	  封包在車載網路中傳遞，因為整個網路的結構一直不斷的在變化，封包是否可以正確的傳出去到讓每個節點都收到，是一個重要的課題，
	  因此對於整個網路所有節點，有多少個節點收到同一個封包訊息，這個比例也就是車載網路封包傳輸的效能比率。
	  另外，封包在傳遞路徑上可能受到各種因素的限制與干擾，造成傳遞失敗，通常會利用重送的方法來做補救的機制，
	  但是每一次傳遞的動作都將耗費不小的成本，因此每個結點所收到封包的成本，便是有多少其他的節點傳給該節點封包的總次數，
	  也就是說該節點能取得封包，全是因為其他能傳給他的節點不斷的與其溝通的結果，因此這樣取得的代價，便是其封包接收的成本。
	</p>
      </section>

      <section>
	<h2>影響封包傳遞之控制變因</h2>
	<h3 class="layer1">1. 可傳送距離</h3>
	<p class="layer2">
	  &nbsp;&nbsp;&nbsp;&nbsp;
	  訊號能傳送的距離往往是最基本的限制條件，在車載網路之中，每台行使中的車輛都是一個訊號傳送端，即所謂的AP, 他會已廣播的方式將封包傳送給與他鄰近的車輛節點，
	  而這個可接收其封包的距離就是這個發送端AP所能傳送的距離。舉例來說，假設傳送端節點可傳送的距離為可傳送的距離為100公尺，則在該節點方圓100公尺範圍內的其他節點，
	  理論上皆能收到傳送端節點所廣播的封包。
	</p>
	<h3 class="layer1">2. 重傳次數</h3>
	<p class="layer2">
	  &nbsp;&nbsp;&nbsp;&nbsp;
	  傳送端發送封包，當接收端收到後會回傳ACK告知傳送端已確實收到，而若傳送端時時沒有收到接收端的ACK訊息，則會在執行重送。
	  而在車載網路中使用Flooding的方式，接收端亦是傳送端，接收端所收到的每一個封包，皆會傳給所有在範圍內的所有節點，如此一來，發送端可能針對同一個訊息內容傳送給鄰近的節點不只一次，
	  重傳的次數越高，每個節點所能正確接收到訊息的機率越大，但同個訊息已在接收端收到而發送端仍持續傳送，就會形成資源的浪費。理論上希望重傳可以無限次數，但實際上我們需要規範每個節點所可以重傳的最多次數，
	  來避免成本的浪費。
	</p>
	<h3 class="layer1">3. 傳送成功率</h3>
	<p class="layer2">
	  &nbsp;&nbsp;&nbsp;&nbsp;
	  傳送端在發送封包的時候，也可能受到各種因素的影響而無法成功的發送出去，實際情況也是如此，不太可能預期每一次的傳送封包行為都是有效的，總會有失誤的時候，
	  這樣的因素也將造成封包是否能順利的傳送出去，因此也考慮進模擬系統，以機率的方式來影響模擬結果。
	</p>
	<h3 class="layer1">4. 接收成功率</h3>
	<p class="layer2">
	  &nbsp;&nbsp;&nbsp;&nbsp;
	  封包透過傳送端以電磁波的方式傳給接收端，而在以電磁波傳遞的過程當中，可能受到雜訊的干擾或是其他不可預期的外在環境因素等影響，封包可能無法成功的在接收端成功接收，
	  這樣的因素也將造成封包是否能順利的傳送出去，因此也考量進模擬系統，以機率的方式來影響模擬結果。
	</p>
      </section>

      <section>
	<h2>簡化問題</h2>
	<h3 class="layer1">1. 一維空間</h3>
	<p class="layer2">
	  &nbsp;&nbsp;&nbsp;&nbsp;
	  高速公路通常有好幾線道，在分析彼此車輛的距離應為二維的空間較為合理，但為了簡化問題，以一維空間來計算，所有的車輛節點接在通一條直線上，
	  如此與二維的空間分佈來說並不會有太大的差異，因為所針對的是一個距離的量值。
	</p>
	<h3 class="layer1">2. 固定所有節點</h3>
	<p class="layer2">
	  &nbsp;&nbsp;&nbsp;&nbsp;
	  在高速公路中，因為有規範車速限制，行使車輛之間的速度變化不大，為簡化問題，可以假設彼此之間的相對距離為固定，將所有行使車輛之車速視為皆等速度行進。
	</p>
	<h3 class="layer1">3. 距離決定接收順序</h3>
	<p class="layer2">
	  &nbsp;&nbsp;&nbsp;&nbsp;
	  當進行Flooding傳送封包的方法中，同一個封包之訊息內容可能由多個節點而來，因此所接收到的時候理應有先後順序，而為了簡化問題，
	  設定由距離來決定取得封包的優先順序，也就是說，當兩個傳送端一個距離接收端較近，另一個較遠，則會先收到近端的封包，接著才會收到遠端的封包。
	</p>
	<h3 class="layer1">4. 只往後傳</h3>
	<p class="layer2">
	  &nbsp;&nbsp;&nbsp;&nbsp;
	  原來Flooding的傳送方法為只要收到就傳給周遭所有可以傳到的節點，因此以高速公路的車輛為例，
	  後方的車輛仍可能向前傳遞，為了簡化問題，我們設定封包的傳遞只能往後傳。
	</p>
      </section>

      <section>
	<h2>程式說明</h2>
	<p>
	  &nbsp;&nbsp;&nbsp;&nbsp;
	  所有程式與相關結果開放在<a href="https://github.com/wonderchang/freeway-ad-hoc">Github<img src="github.gif" height="25" align="top" /></a>。
	</p>
	<h3 class="layer1">1. 參數設定</h3>
	<p class="layer2">
	  &nbsp;&nbsp;&nbsp;&nbsp;
	  依據四個影響傳遞效能與成本的控制變因，可傳距離 （DISTANCE）、最多重傳次數（COUNTER）、
	  傳送成功率（PR, Retransmission probability）、接收成功率 （MS_RATE, Message successful rate），
	  將其作為程式執行的輸入參數。
	</p>
	<h3 class="layer2">
	  <div class="code_region">
	    <code>
	      DISTANCE = 50;<br />
	      COUNTER = 2;<br />
	      PR = 0.7;<br />
	      MS_RATE = 0.8;
	    </code>
	  </div>
	</h3>
	<br />
	<h3 class="layer1">2. 資料定義</h3>
	<p class="layer2">
	  &nbsp;&nbsp;&nbsp;&nbsp;
	  整條高速公路有多少輛汽車, 以上述程式碼為例有100輛車在高速公路上。
	</p>
	<h3 class="layer2">
	  <div class="code_region">
	    <code>
	      CAR_NUM = 100;
	    </code>
	  </div>
	</h3>
	<p class="layer2">
	  &nbsp;&nbsp;&nbsp;&nbsp;
	  將每部車以物件形態顯示其資料，每輛車有三個屬性，
	  「id」是車的編號標示每輛車;
	  「x」是其座落的位置，單位為公尺;
	  「counter」表示該車輛已傳送過幾次封包;
	  「received」表是否曾收到過封包，1代表有，0代表無;
	  「packet_num」表示該車輛已收到幾個封包;
	  「reachable」是可傳送距離之車輛節點之列表，以陣列形式記錄。
	  以上程式碼為例，該車的編號為3，其坐落在距離模擬之起始位置的144.78公尺處，
	  供廣播了兩次封包給其他節點，
	  當然能傳給其他人代表曾收到過該封包過，
	  而其收到的封包數目為2個，
	  而其在假設某一可重送距離之下，能與車號為4、5、6、7傳送封包進行溝通。
	</p>
	<h3 class="layer2">
	  <div class="code_region">
	    <code>
	      car = {<br /> 
	      <span class="tab">"id": 3,</span><br />
	      <span class="tab">"x": 144.78,</span><br /> 
	      <span class="tab">"counter": 2,</span><br />
	      <span class="tab">"received: 1,</span><br />
	      <span class="tab">"packet_num": 2,</span><br />
	      <span class="tab">"reachable": [4, 5, 6, 7]</span><br /> 
	      }
	    </code>
	  </div>
	</h3>
	<p class="layer2">
	  &nbsp;&nbsp;&nbsp;&nbsp;
	  整條高速公路長1公里，起始點為0，終點為1000公尺，並以陣列資料形態顯示，
	  裡頭的資料便是每輛車，這些車再整條高速公路的位置隨編號照順序排列，
	  編號小的坐落位置在編好大的前面。
	</p>
	<h3 class="layer2">
	  <div class="code_region">
	    <code>
	      freeway = [car_1, car_2, car_3, ... ..., car_n];
	    </code>
	  </div>
	</h3>
	<br />
	<h3 class="layer1">3. 邏輯與流程</h3>
	<p class="layer2">
	  &nbsp;&nbsp;&nbsp;&nbsp;
	  定義函式pass_packet(car)，其傳入的參數為車輛物件，而因為每輛車皆能知道其可傳送的車輛節點資訊，
	  因此便可以用recursive的方式持續傳遞下去。
	</p>
	<h3 class="layer2">
	  <div class="code_region">
	    <code>
	      pass_packet(car);
	    </code>
	  </div>
	</h3>
	<p class="layer2">
	  &nbsp;&nbsp;&nbsp;&nbsp;
	  進入到函式後，receiver記錄該傳入車的物件可以傳送的節點陣列，receiver_num記錄有多少個可傳節點。
	</p>
	<h3 class="layer2">
	  <div class="code_region">
	    <code>
	      receiver = car.reachable;<br />
	      receiver_num = receiver.length;
	    </code>
	  </div>
	</h3>
	<p class="layer2">
	  &nbsp;&nbsp;&nbsp;&nbsp;
	  接著開始進入重送回圈，決定是否重送根據該節點車輛是否已經超過了重傳得最多次數，還有是否在可傳距離內的依然有可被允許傳送的節點，
	  意思是說receiver陣列是否為空，為空的可能有兩個情況，一個是原本就沒有可傳送的點，另一個是可以傳送的節點都已傳完。
	   
	</p>
	<h3 class="layer2">
	  <div class="code_region">
	    <code>
	      while(car.counter < COUNTER && receiver_num != 0) {<br />
	      <span class="tab">//Try to reboardcast</span><br />
	      }
	    </code>
	  </div>
	</h3>
	<p class="layer2">
	  &nbsp;&nbsp;&nbsp;&nbsp;
	  若符合重送情況，以直骰子的方式取隨機來決定是否傳送成功，當所取的亂數小於等於所定的傳送成功率，則代表傳送成功，而反之大於則不傳送。
	</p>
	<h3 class="layer2">
	  <div class="code_region">
	    <code>
	      if(Math.random() <= PR) {<br />
	      <span class="tab">//Allow to boardcast</span><br />
	      }
	    </code>
	  </div>
	</h3>
	<p class="layer3">
	  &nbsp;&nbsp;&nbsp;&nbsp;
	  當成功後，對所有的節點車輛開始傳送，forEach是針對receiver的所有陣列按順序取出，並回傳在other_car的變數之中。
	</p>
	<h3 class="layer2">
	  <div class="code_region">
	    <code>
	      receiver.forEach(function(other_car) {<br />
	      <span class="tab"></span>//Send the packet to the specific car<br />
	      });
	    </code>
	  </div>
	</h3>
	<p class="layer2">
	  &nbsp;&nbsp;&nbsp;&nbsp;
	  並在針對每一個個別節點車輛隻傳送取亂數決定是否接收成功，同理根據所輸入的接收成功率 （MS_RATE），小於等於則成功，大於則失敗。
	  因已確定收到封包，因此再接續以該接收節點變成傳送節點傳送封包下去。
	</p>
	<h3 class="layer2">
	  <div class="code_region">
	    <code>
	      if(Math.random() <= MS_RATE) {<br />
	      <span class="tab">//The receiver get the packet successfully</span><br />
	      <span class="tab">//Pass to next car</span><br />
	      <span class="tab">pass_packet(next_car);</span><br />
	      }
	    </code>
	  </div>
	</h3>
	<br />
	<h3 class="layer1">4. 執行環境 </h3>
	<p class="layer2">
	  &nbsp;&nbsp;&nbsp;&nbsp;
	  本程式使用Javascript所編寫，透過google chrome之V8直譯引擎與<a href="http://nodejs.org">nodejs</a>相關模組所執行，檔名為main.js，
	  輸入以下指令於命令列，四個參數順序如下：
	</p>
	<h3 class="layer2">
	  <div class="code_region">
	    <code>
	      $ node main.js [DISTANCE] [COUNTER] [PR] [MS_RATE]
	    </code>
	  </div>
	</h3>
	<p class="layer2"> 例如：</p>
	<h3 class="layer2">
	  <div class="code_region">
	    <code>
	      $ node main.js 50 2 0.7 0.8
	    </code>
	  </div>
	</h3>
	<br />
	<h3 class="layer1">5. 輸出資料 </h3>
	<p class="layer2">
	  &nbsp;&nbsp;&nbsp;&nbsp;
	  每一次執行產生兩個資料輸出檔案，針對同個參數情況下，一個為車輛數目與效能的變化，另一個是車輛數目與成本的變化，格式為tsv
	  以上述為例，講產生以下兩個資料輸出檔：
	</p>
	<span class="layer2">d-50_c-2_pr-07_ms-08_effi.tsv</span>
	<h3 class="layer2">
	  <div class="code_region">
	    <code>
	      num<span class="tab"> rate</span><br />
	      10 &nbsp;<span class="tab">0.0493</span><br />
	      50 &nbsp;<span class="tab">0.1921</span><br />
	      100 <span class="tab">0.695</span><br />
	      150 <span class="tab">0.9611</span><br />
	      200 <span class="tab">0.9988</span><br />
	      250 <span class="tab">0.9998</span><br />
	      300 <span class="tab">0.9998</span><br />
	      350 <span class="tab">0.9998</span><br />
	      400 <span class="tab">0.9998</span><br />
	      450 <span class="tab">0.9999</span><br />
	      500 <span class="tab">0.9999</span><br />
	      550 <span class="tab">0.9998</span><br />
	      600 <span class="tab">0.9999</span><br />
	      650 <span class="tab">0.9999</span><br />
	      700 <span class="tab">0.9999</span><br />
	      750 <span class="tab">0.9999</span><br />
	      800 <span class="tab">0.9999</span><br />
	      850 <span class="tab">0.9999</span><br />
	      900 <span class="tab">0.9999</span><br />
	      950 <span class="tab">0.9999</span><br />
	      1000<span class="tab">0.9999</span><br />
	    </code>
	  </div>
	</h3>
	<span class="layer2">d-50_c-2_pr-07_ms-08_effi.tsv</span>
	<h3 class="layer2">
	  <div class="code_region">
	    <code>
	      num<span class="tab"> rate</span><br />
	      10 &nbsp;<span class="tab">0.4323</span><br />
	      50 &nbsp;<span class="tab">3.0895</span><br />
	      100 <span class="tab">7.0249</span><br />
	      150 <span class="tab">10.0912</span><br />
	      200 <span class="tab">12.7916</span><br />
	      250 <span class="tab">15.4464</span><br />
	      300 <span class="tab">18.1571</span><br />
	      350 <span class="tab">20.9131</span><br />
	      400 <span class="tab">23.7559</span><br />
	      450 <span class="tab">26.5568</span><br />
	      500 <span class="tab">29.4072</span><br />
	      550 <span class="tab">32.3042</span><br />
	      600 <span class="tab">35.1873</span><br />
	      650 <span class="tab">38.077</span><br />
	      700 <span class="tab">41.0007</span><br />
	      750 <span class="tab">43.851</span><br />
	      800 <span class="tab">46.8179</span><br />
	      850 <span class="tab">49.7613</span><br />
	      900 <span class="tab">52.7002</span><br />
	      950 <span class="tab">55.5953</span><br />
	      1000<span class="tab">58.4596</span>
	    </code>
	  </div>
	</h3>
	<br />
      </section>
      <section>
	<h2>模擬成果</h2>
	<p>根據四個控制因素，我們可以簡單控制一些參數來觀察彼此之間的影響</p>
	<div class="graph">
	  <div class="left-graph"></div>
	  <div class="right-graph"></div>
	  <div class="left-graph-label">Figure 1, 效能比率</div>
	  <div class="right-graph-label">Figure 2, 傳送成本比率</div>
	</div>
      </section>


    <script src="http://d3js.org/d3.v3.js"></script>
    <script src="./dynamic-car-flow/app.js"></script>
    <script src="./app.js"></script>
    <script>

      var left_graph = d3.select(".left-graph").append("svg").attr("width", 480).attr("height",350).append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");
      var left_color_set = d3.scale.category10();
      var left_color_counter = 0;
      draw_line(left_graph, "./distance/data/d-10_c-2_msr-0.8_pr-0.7_effi.tsv", left_color_set, left_color_counter++, 0);
      draw_line(left_graph, "./distance/data/d-25_c-2_msr-0.8_pr-0.7_effi.tsv", left_color_set, left_color_counter++, 0);
      draw_line(left_graph, "./distance/data/d-50_c-2_msr-0.8_pr-0.7_effi.tsv", left_color_set, left_color_counter++, 0);
      draw_line(left_graph, "./distance/data/d-70_c-2_msr-0.8_pr-0.7_effi.tsv", left_color_set, left_color_counter++, 0);

      var right_graph = d3.select(".right-graph").append("svg").attr("width", 480).attr("height", 350).append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");
      var right_color_set = d3.scale.category10();
      var right_color_counter = 0;
      draw_line(right_graph, "./distance/data/d-10_c-2_msr-0.8_pr-0.7_cost.tsv", right_color_set, right_color_counter++, 80);
      draw_line(right_graph, "./distance/data/d-25_c-2_msr-0.8_pr-0.7_cost.tsv", right_color_set, right_color_counter++, 80);
      draw_line(right_graph, "./distance/data/d-50_c-2_msr-0.8_pr-0.7_cost.tsv", right_color_set, right_color_counter++, 80);
      draw_line(right_graph, "./distance/data/d-70_c-2_msr-0.8_pr-0.7_cost.tsv", right_color_set, right_color_counter++, 80);
 
    </script>
  </body>
</html>
